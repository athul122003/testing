generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

//User and Profile
model User {
  id            Int       @id @default(autoincrement())
  name          String
  email         String    @unique
  emailVerified DateTime?
  usn           String    @unique
  password      String
  phone         String
  image         String?
  year          String
  roleId        String
  role          Role      @relation(fields: [roleId], references: [id])

  bio                 String    @default("")
  memberSince         DateTime?
  totalActivityPoints Int       @default(0)

  strikes     Strike[]
  strikeCount Int      @default(0)
  banCount    Int      @default(0)

  reasonToJoin String?
  expectations String?
  contribution String?
  githubLink   String?

  branchId  String?
  Branch    Branch?    @relation(fields: [branchId], references: [id], onDelete: SetNull) //modified
  UserLink  UserLink[]
  Blog      Blog[]
  paymentId String?    @unique
  Payment   Payment?   @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  Attendance        Attendance[]
  TeamLeader        Team[]              @relation("leaderOfTeam")
  Team              Team[]
  Organiser         Organiser[]
  Core              Core[]
  Certificate       Certificate[]
  FeedbackResponse  FeedbackResponse[]
  RefreshToken      RefreshToken[]
  VerificationToken VerificationToken[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  revokedMembers revokedMembers?
  easterEgg      EasterEgg?      @relation(fields: [easterEggId], references: [id])
  easterEggId    Int?
  WordleGame     WordleGame[]
}

model Strike {
  id        String   @id @default(cuid())
  reason    String
  createdAt DateTime @default(now())

  userId Int
  User   User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model revokedMembers {
  id     String @id @default(cuid())
  userId Int    @unique
  User   User   @relation(fields: [userId], references: [id])
  roleId String
  Role   Role   @relation(fields: [roleId], references: [id])

  @@unique([userId, roleId])
}

model Role {
  id             String           @id @default(cuid())
  name           String
  users          User[]
  permissions    RolePermission[]
  revokedMembers revokedMembers[]

  @@unique([name])
}

model Permission {
  id    String           @id @default(cuid())
  name  String           @unique
  roles RolePermission[]
}

model RolePermission {
  id           String @id @default(cuid())
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([roleId, permissionId])
}

model Branch {
  id       String @id @default(cuid())
  nickName String
  name     String

  User User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserLink {
  id       String @id @default(cuid())
  linkName String
  url      String

  userId Int?
  User   User? @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Core {
  id     String @id @default(cuid())
  User   User   @relation(fields: [userId], references: [id])
  userId Int

  type     CoreType @default(OFFICE_BEARER)
  position String
  year     String
  priority Int
}

//Auth 
model RefreshToken {
  id          String  @id @unique
  hashedToken String
  revoked     Boolean @default(false)

  userId Int
  User   User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([id, hashedToken])
}

model VerificationToken {
  id      String           @id @unique @default(cuid())
  revoked Boolean          @default(false)
  type    VerificationType @default(EMAIL_VERIFICATION)

  userId Int
  User   User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Events , Feedback and Participation
model Event {
  id          Int     @id @default(autoincrement())
  name        String
  imgSrc      String?
  description String? @db.Text
  venue       String?

  eventType EventType
  category  EventCategory

  fromDate    DateTime
  toDate      DateTime
  deadline    DateTime?
  maxTeams    Int       @default(0)
  minTeamSize Int       @default(1)
  maxTeamSize Int       @default(1)

  isMembersOnly Boolean @default(false)
  flcAmount     Int     @default(0)
  nonFlcAmount  Int     @default(0)

  state                    EventState @default(DRAFT)
  isLegacy                 Boolean    @default(false)
  prizesAlloted            Boolean    @default(false)
  statusOfBatchRestriction Boolean    @default(false)
  batchRestriction         Batch[]

  Organiser     Organiser[]
  Team          Team[]
  Attendance    Attendance[]
  Prize         Prize[]
  Certificate   Certificate[]
  Feedback      Feedback[]
  EventDocument EventDocument[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Batch {
  id   String @id @default(cuid())
  year Int

  maxCapacity Int @default(0)

  eventId Int
  events  Event @relation(fields: [eventId], references: [id])
}

model Attendance {
  id          String  @id @default(cuid())
  hasAttended Boolean @default(false)

  eventId Int
  Event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId Int
  User   User @relation(fields: [userId], references: [id])

  teamId String
  Team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
  @@index([userId, eventId])
}

model Organiser {
  id String @id @default(cuid())

  eventId Int
  Event   Event @relation(fields: [eventId], references: [id])

  userId Int
  User   User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
  @@index([userId, eventId])
}

model Team {
  id          String  @id @default(cuid())
  name        String
  isConfirmed Boolean @default(false)
  hasAttended Boolean @default(false)
  yearOfStudy Int?

  eventId Int
  Event   Event @relation(fields: [eventId], references: [id])

  leaderId Int
  Leader   User @relation("leaderOfTeam", fields: [leaderId], references: [id])

  Members    User[]
  Attendance Attendance[]
  prizeId    String?
  Prize      Prize?       @relation(fields: [prizeId], references: [id])

  paymentId String?  @unique
  Payment   Payment? @relation(fields: [paymentId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Prize {
  id        String    @id @default(cuid())
  prizeType PrizeType @default(PARTICIPATION)

  flcPoints Int   @default(0)
  eventId   Int
  Event     Event @relation(fields: [eventId], references: [id])

  Teams Team[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, prizeType])
}

model Feedback {
  id            String        @id @default(cuid())
  title         String
  feedbackState FeedbackState @default(DRAFT)
  questions     Json[] // feedbackQuestionZ

  eventId Int
  Event   Event @relation(fields: [eventId], references: [id])

  FeedbackResponse FeedbackResponse[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id      String @id @default(cuid())
  answers Json[] // feedbackAnswerZ

  userId Int
  User   User @relation(fields: [userId], references: [id])

  feedbackId String
  Feedback   Feedback @relation(fields: [feedbackId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, feedbackId])
  @@index([userId, feedbackId])
}

model Certificate {
  id              String          @id @default(cuid())
  issuedOn        DateTime
  certificateType CertificateType

  link    String? // URL to certificate file
  eventId Int
  Event   Event   @relation(fields: [eventId], references: [id])

  userId Int
  User   User @relation(fields: [userId], references: [id])

  statusOfMailing Boolean @default(false) //new: to check if the certificate is mailed or not
  errorInMailing  Boolean @default(false) //new: to check if there was an error while mailing the certificate

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([userId, eventId])
}

// Blog
model Blog {
  id          String    @id @unique @default(cuid())
  title       String
  slug        String?   @unique //new
  description String    @db.Text //corrected spelling 
  content     String    @db.Text
  readTime    Int
  words       Int
  coverImage  String? //new: cover image url for the blog
  blogState   BlogState @default(DRAFT)

  userId Int
  User   User @relation(fields: [userId], references: [id])

  reviewState reviewState @default(PENDING) //new to notify the user whether the blog is approved rejected or pending review
  feedback    String? //new:feedback from the reviewer(admin) to the user(blog author)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EventDocument {
  id          String  @id @default(cuid())
  name        String
  description String?
  fileUrl     String
  fileType    String?
  fileSize    Int?

  eventId Int
  Event   Event @relation(fields: [eventId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EasterEgg {
  id        Int    @id @default(autoincrement())
  name      String
  detail    String
  flcPoints Int    @default(0)
  foundBy   User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// //Quiz
// model Quiz {
//   id        String    @id @default(cuid())
//   title     String
//   quizState QuizState @default(DRAFT)
//   timeLimit Int
//   maxPoints Int
//   questions Json[] // quizQuestionZ

//   QuizResponse QuizResponse[]

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

// model QuizResponse {
//   id      String @id @default(cuid())
//   score   Int    @default(0)
//   answers Json[] // quizAnswerZ

//   userId Int
//   User   User @relation(fields: [userId], references: [id])

//   quizId String
//   Quiz   Quiz   @relation(fields: [quizId], references: [id])

//   createdAt DateTime @default(now())
//   updatedAt DateTime @default(now())

//   @@unique([userId, quizId])
//   @@index([userId, quizId])
// }

//Payment
model Payment {
  id          String      @id @default(cuid())
  paymentName String
  amount      Int
  paymentType PaymentType

  razorpayOrderId   String
  razorpayPaymentId String
  razorpaySignature String

  User User?
  Team Team?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Settings {
  id          String  @id @default(cuid())
  name        String
  value       String?
  status      Boolean
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name])
}

//Wordle 
model WordleWord {
  id        String        @id @default(uuid())
  word      String        @unique
  length    Int
  createdAt DateTime      @default(now())

  games     WordleGame[]

  @@index([length])
}

model WordleGame {
  id            String            @id @default(uuid())

  userId        Int
  wordId        String

  gameDate      DateTime          @db.Date
  attemptsUsed  Int               @default(0)
  status        WordleGameStatus  @default(IN_PROGRESS)

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  user          User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  word          WordleWord         @relation(fields: [wordId], references: [id])

  guesses       WordleGuess[]

  @@unique([userId, gameDate])
  @@index([userId])
  @@index([status])
}

model WordleGuess {
  id        String      @id @default(uuid())
  gameId   String

  guess     String
  result    Json

  createdAt DateTime    @default(now())

  game      WordleGame  @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId])
}

enum EventCategory {
  WORKSHOP
  COMPETITION
  HACKATHON
  SPECIAL
}

enum EventType {
  SOLO
  TEAM
}

enum PrizeType {
  WINNER
  RUNNER_UP
  SECOND_RUNNER_UP
  PARTICIPATION
}

enum CertificateType {
  WINNER
  RUNNER_UP
  SECOND_RUNNER_UP
  PARTICIPATION
}

enum VerificationType {
  PASSWORD_RESET
  EMAIL_VERIFICATION
}

enum EventState {
  DRAFT
  PUBLISHED
  LIVE
  COMPLETED
}

enum FeedbackState {
  DRAFT
  PUBLISHED
  LIVE
  COMPLETED
}

// enum QuizState {
//   DRAFT
//   PUBLISHED
//   LIVE
//   COMPLETED
// }

enum BlogState {
  DRAFT
  PUBLISHED
}

enum reviewState {
  PENDING
  APPROVED
  REJECTED
}

enum PaymentType {
  MEMBERSHIP
  EVENT
}

enum CoreType {
  OFFICE_BEARER
  FACULTY_COORDINATOR
}

enum WordleGameStatus {
  IN_PROGRESS
  WON
  LOST
}
